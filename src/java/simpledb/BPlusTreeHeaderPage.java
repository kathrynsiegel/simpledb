package simpledb;

import java.io.*;

/**
 * Each instance of BPlusTreeHeaderPage stores data for one page of a BPlusTreeFile and 
 * implements the Page interface that is used by BufferPool.
 *
 * @see BPlusTreeFile
 * @see BufferPool
 *
 */
public class BPlusTreeHeaderPage implements Page {
	private volatile boolean dirty = false;
	private volatile TransactionId dirtier = null;
	
	final static int INDEX_SIZE = Type.INT_TYPE.getLen();

	final BPlusTreePageId pid;
	final byte header[];
	final int numSlots;

	private int nextPage; // next header page or 0
	private int prevPage; // previous header page or 0

	byte[] oldData;
	private final Byte oldDataLock=new Byte((byte)0);

	/**
	 * Create a BPlusTreeHeaderPage from a set of bytes of data read from disk.
	 * The format of a BPlusTreeHeaderPage is two pointers to the next and previous
	 * header pages, followed by a set of bytes indicating which pages in the file
	 * are used or available
	 * @see BufferPool#getPageSize()
	 * 
	 */
	public BPlusTreeHeaderPage(BPlusTreePageId id, byte[] data) throws IOException {
		this.pid = id;
		this.numSlots = getNumSlots();
		DataInputStream dis = new DataInputStream(new ByteArrayInputStream(data));

		// Read the next and prev pointers
		try {
			Field f = Type.INT_TYPE.parse(dis);
			this.nextPage = ((IntField) f).getValue();
		} catch (java.text.ParseException e) {
			e.printStackTrace();
		}

		try {
			Field f = Type.INT_TYPE.parse(dis);
			this.prevPage = ((IntField) f).getValue();
		} catch (java.text.ParseException e) {
			e.printStackTrace();
		}

		// allocate and read the header slots of this page
		header = new byte[getHeaderSize()];
		for (int i=0; i<header.length; i++)
			header[i] = dis.readByte();

		dis.close();

		setBeforeImage();
	}

	/**
	 * Initially mark all slots in the header used.
	 */
	public void init() {
		for (int i=0; i<header.length; i++)
			header[i] = (byte) 0xFF;
	}

	/**
	 * Computes the number of bytes in the header while saving room for pointers
	 */
	private static int getHeaderSize() {        
		// pointerBytes: nextPage and prevPage pointers
		int pointerBytes = 2 * INDEX_SIZE; 
		return BufferPool.getPageSize() - pointerBytes;
	}

	/**
	 * Computes the number of slots in the header
	 */
	public static int getNumSlots() {        
		return getHeaderSize() * 8;
	}

	/** Return a view of this page before it was modified
        -- used by recovery */
	public BPlusTreeHeaderPage getBeforeImage(){
		try {
			byte[] oldDataRef = null;
			synchronized(oldDataLock)
			{
				oldDataRef = oldData;
			}
			return new BPlusTreeHeaderPage(pid,oldDataRef);
		} catch (IOException e) {
			e.printStackTrace();
			//should never happen -- we parsed it OK before!
			System.exit(1);
		}
		return null;
	}

	public void setBeforeImage() {
		synchronized(oldDataLock)
		{
			oldData = getPageData().clone();
		}
	}

	/**
	 * @return the PageId associated with this page.
	 */
	public BPlusTreePageId getId() {
		return pid;
	}

	/**
	 * Generates a byte array representing the contents of this page.
	 * Used to serialize this page to disk.
	 * <p>
	 * The invariant here is that it should be possible to pass the byte
	 * array generated by getPageData to the BPlusTreeHeaderPage constructor and
	 * have it produce an identical BPlusTreeHeaderPage object.
	 *
	 * @see #BPlusTreeHeaderPage
	 * @return A byte array correspond to the bytes of this page.
	 */
	public byte[] getPageData() {
		int len = BufferPool.getPageSize();
		ByteArrayOutputStream baos = new ByteArrayOutputStream(len);
		DataOutputStream dos = new DataOutputStream(baos);

		// write out the next and prev pointers
		try {
			dos.writeInt(nextPage);

		} catch (IOException e) {
			e.printStackTrace();
		}
		try {
			dos.writeInt(prevPage);

		} catch (IOException e) {
			e.printStackTrace();
		}

		// create the header of the page
		for (int i=0; i<header.length; i++) {
			try {
				dos.writeByte(header[i]);
			} catch (IOException e) {
				// this really shouldn't happen
				e.printStackTrace();
			}
		}

		try {
			dos.flush();
		} catch (IOException e) {
			e.printStackTrace();
		}

		return baos.toByteArray();
	}

	/**
	 * Static method to generate a byte array corresponding to an empty
	 * BPlusTreeHeaderPage.
	 * Used to add new, empty pages to the file. Passing the results of
	 * this method to the BPlusTreeHeaderPage constructor will create a BPlusTreeHeaderPage with
	 * no valid data in it.
	 *
	 * @return The returned ByteArray.
	 */
	public static byte[] createEmptyPageData() {
		int len = BufferPool.getPageSize();
		return new byte[len]; //all 0
	}

	/**
	 * Get the page id of the previous header page
	 * @return the page id of the previous header page
	 */
	public BPlusTreePageId getPrevPageId() {
		if(prevPage == 0) {
			return null;
		}
		return new BPlusTreePageId(pid.getTableId(), prevPage, BPlusTreePageId.HEADER);
	}

	/**
	 * Get the page id of the next header page
	 * @return the page id of the next header page
	 */
	public BPlusTreePageId getNextPageId() {
		if(nextPage == 0) {
			return null;
		}
		return new BPlusTreePageId(pid.getTableId(), nextPage, BPlusTreePageId.HEADER);
	}

	/**
	 * Set the page id of the previous header page
	 * @param id - the page id of the previous header page
	 * @throws DbException
	 */
	public void setPrevPageId(BPlusTreePageId id) throws DbException {
		if(id == null) {
			prevPage = 0;
		}
		else {
			if(id.getTableId() != pid.getTableId()) {
				throw new DbException("table id mismatch in setPrevPageId");
			}
			if(id.pgcateg() != BPlusTreePageId.HEADER) {
				throw new DbException("prevPage must be a header page");
			}
			prevPage = id.pageNumber();
		}
	}

	/**
	 * Set the page id of the next header page
	 * @param id - the page id of the next header page
	 * @throws DbException
	 */
	public void setNextPageId(BPlusTreePageId id) throws DbException {
		if(id == null) {
			nextPage = 0;
		}
		else {
			if(id.getTableId() != pid.getTableId()) {
				throw new DbException("table id mismatch in setNextPageId");
			}
			if(id.pgcateg() != BPlusTreePageId.HEADER) {
				throw new DbException("nextPage must be a header page");
			}
			nextPage = id.pageNumber();
		}
	}

	/**
	 * Marks this page as dirty/not dirty and record that transaction
	 * that did the dirtying
	 */
	public void markDirty(boolean dirty, TransactionId tid) {
		this.dirty = dirty;
		if (dirty) this.dirtier = tid;
	}

	/**
	 * Returns the tid of the transaction that last dirtied this page, or null if the page is not dirty
	 */
	public TransactionId isDirty() {
		if (this.dirty)
			return this.dirtier;
		else
			return null;
	}

	/**
	 * Returns true if the page of the BPlusTreeFile associated with slot i is used
	 */
	public boolean isSlotUsed(int i) {
		int headerbit = i % 8;
		int headerbyte = (i - headerbit) / 8;
		return (header[headerbyte] & (1 << headerbit)) != 0;
	}

	/**
	 * Abstraction to mark a page of the BPlusTreeFile used or unused
	 */
	public void markSlotUsed(int i, boolean value) {
		int headerbit = i % 8;
		int headerbyte = (i - headerbit) / 8;

		Debug.log(1, "BPlusTreeHeaderPage.setSlot: setting slot %d to %b", i, value);
		if(value)
			header[headerbyte] |= 1 << headerbit;
		else
			header[headerbyte] &= (0xFF ^ (1 << headerbit));
	}

	/**
	 * get the index of the first empty slot
	 * @return the index of the first empty slot or -1 if none exists
	 */
	public int getEmptySlot() {
		for (int i=0; i<header.length; i++) {
			if((int) header[i] != 0xFF) {
				for(int j = 0; j < 8; j++) {
					if(!isSlotUsed(i*8 + j)) {
						return i*8 + j;
					}
				}
			}
		}
		return -1;
	}
}